---
title: "Introducción a R y Rstudio"
authors: ["Zulma M. Cucunuba","José M. Velasco-España","Andree Valle-Campos"]
date: '2022-10-24'
output:
  html_document: 
    self_contained: true
  pdf_document: default
  word_document: default
image: null
licenses: CC-BY
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Introducción

En este taller usted aprenderá a reconocer los distintos elementos en la
interfaz del RStudio, estructuras en R y manejo de datos con Tidyverse.
Este taller se realizará mediante el uso de una guía de aprendizaje.

## 2. Objetivos

-   Recordar que es R y RStudio.

-   Reconocer la interfaz de RStudio.

-   Describir las estructuras básicas en R: vectores, matrices, bases de
    datos y listas.

-   Reconocer el proceso de importación, exportación y transformación de
    bases de datos con tidyverse.

-   Describir el proceso de creación de funciones

## 3. Conceptos básicos a desarrollar

En esta práctica se desarrollarán los siguientes conceptos:

-   Estructuras básicas en R: vectores, matrices, bases de datos y
    listas.

-   Importación, exportación y transformación de bases de datos.

## 4. Introducción a R

R es un lenguaje de programación libre sucesor del lenguaje S. Fue
creado por Ross Ihaka y Robert Gentleman en 1991 para uso en la
enseñanza, posteriormente en 1993 fue difundido entre la comunidad de
usuarios de S. Fue hasta 1995 que por motivación de Martin Mächler de la
ETH Zurich R fue lanzado como software libre con código fuente
disponible por ftp bajo los términos de la licencia general GNU de la
Free Software Foundation.

R además de ser un lenguaje de programación es un entorno para
computación estadística y creación de gráficos.
[R-project](https://cran.r-project.org/doc/html/interface98-paper/paper_2.html)

## 5. Ambiente de R

La parte visual de RStudio esta compuesta por 4 áreas principalmente:

![](img/Ambiente.png)

1.  Editor: Esta sección es fundamental para la reproducibilidad del
    código. Este editor permite guardar el código para que sea usado en
    futuras ocasiones. El código puede ser ejecutado en esta sección
    posicionando el cursor de texto al final de la línea de código que
    se ejecutará o seleccionando la misma y empleando el comando
    control+enter para windows o command+enter para mac.

2.  Entorno: En esta sección se pueden visualizar los objetos y
    funciones creados o importados en la sección de R. Objetos como
    vectores, matrices, arreglos, data frames, listas, objetos tipo
    ggplot, entre otros.

3.  Consola: Esta sección es donde se ejecuta el código. No solo se
    ejecuta el código que se ejecute en el editor, sino también el
    código puede escribirse aquí y ejecutarse presionando enter. Sin
    embargo, cuando el código se ejecuta directamente en la consola este
    no se almacena y cuando se cierra la sesión de R este se pierde.

4.  Visualizador: En esta sección se pueden visualizar los archivos en
    "Files", los gráficos en "Plots", los paquetes que ya están
    instalados en "Packages", la ayuda de R con información de los
    paquetes y el funcionanmiento en "Help" y páginas web en "Viewer".

## 6. Configuración de un proyecto en R

Una de las grandes ventajas de usar RStudio es la posibilidad de usar
los Proyectos en R (R Project)(indicado por un archivo `.Rproj`) lo que
permite organizar el espacio de trabajo, el historial y los documentos
fuente.

Para crear un Proyecto en R, siga los siguientes pasos:

(1) Abra RStudio y en la esquina superior derecha, seleccione la pestaña
    *File* (Archivo) -\> *New Project...* (Proyecto Nuevo).
(2) Se desplegará una ventana con encabezado *New Project Wizard: Create
    Project*, ahora seleccione *New Directory* (Directorio Nuevo).

![Screenshot New Directory](img/NewDirectory.png)

(3) En la ventana *Project Type*, cree un nuevo proyecto en Rstudio
    seleccionando *New Project* -\> *Create New Project*, en la casilla
    *Directory Name* (Nombre del Directorio) coloque el nombre "introR".


(4) Seleccione el botón *Browse...*, ahora debe crear una carpeta que
    servira de repositorio para su proyecto, así como las sub carpetas
    que necesita para organizar su trabajo (por ejemplo: datos, scripts,
    figuras). Al final seleccione la carpeta que servirá de repositorio.

Al final, su proyecto debería parecerse a esta imagen

![Screenshot R Project](img/Rproject.png)

Al final, su proyecto debería parecerse a esta imagen

## 7. Datos en R

R tiene la capacidad de almacenar y procesar distintos tipos de datos.
Entre estos se encuentran:

1.  Datos numéricos fraccionados (double. Ej: 3.3)

2.  Datos enteros (integer. Ej: 3)

3.  Datos en caracteres (character)

4.  Operadores aritméticos (Ej: +, -, \*)

5.  Operadores de comparación (Ej: \<, \>, ==, \>=, \<=, !=)

6.  Tipos de datos booleanos/ Datos lógicos (logic. Ej: FALSE, TRUE)

7.  Operadores booleanos (& (and), \| (or), ! (not))

8.  Datos factor (factor. Sirven para categorizar. Ej: femenino,
    masculino, otro o primero, segundo.)

9.  Datos tipo fechas (date. Ej: 01/01/2022)

10. Datos NA, NAN e Inf

### Variables

Hay una forma que tiene R de almacenar un dato importante la cual es
mediante el uso de variables. Las variables son objetos de R que pueden
almacenar datos nuevos, resultados de operaciones, entre otros. Y pueden
ser actualizadas si es necesario. Estas variables tienen un nombre que
las identifica de manera única, de modo que si otra variable tiene el
mismo nombre los datos que se encontraban en esa variable se perderían.
Para crear estos nombres hay algunas reglas básicas:

-   Usar minúsculas
-   Siempre debe comenzar con letras, a continuación pueden ir letras,
    números o el símbolo de guión bajo "\_"
-   no usar espacios, para separar usar guión bajo "\_"

Para almacenar los datos en una variable se seguirá esta secuencia:

1.  nombre_de_la_variable
2.  Símbolo de asignación \<-
3.  lo que se desea almacenar

Por ejemplo:

```{r}
suma <- 3 + 2 

suma

resta <- 3 - 2

resta

comparación <- 3 > 2

```

### Funciones

Una función es una de las estructuras que hace de *R* una plataforma
muy potente para la programación.

Hay varios tipos de funciones:

-   *Funciones básicas o primitivas*: estas son las funciones
    predeterminadas en *R* bajo el *base package (paquete base)*. Por
    ejemplo, pueden incluir operaciones aritméticas básicas, pero
    también operaciones más complejas como la extracción de valores,
    calculo de la mediana `median` o `summary (resumen)` de una
    variable.

    -   *Funciones de paquetes*: son funciones creadas dentro de un
        paquete. Por ejemplo, la función `glm` en el paquete *stats*
        (*stats* package).
    -   *Funciones creadas por el usuario*: son funciones que cualquier
        usuario crea para una rutina personalizada. Estas funciones
        podrían formar parte de un paquete.

Los componentes básicos de una función son:

-   *name (nombre)*: es el nombre que se da a la función(Por ejemplo:
    `myfun`)
-   *formals (argumentos)*: son la serie de elementos que controlan cómo
    llamar a la función.
-   *body (cuerpo)*: es la serie de operaciones o modificaciones a los
    argumentos.
-   *output (salida o resultado)*: son los resultados después de
    modificar los argumentos. Si esta salida corresponde a una serie de
    datos, podemos extraerla usando el comando `return`.

#### Función creada por el usuario

Para crear una función que calcula el Indice de Masa Corporal (IMC)

```{r}
# Inicialmente poner el nombre a la función (ej. mifun)
imc <- function(peso, talla) # Los argumentos (peso y talla)
{ 
  # Ahora escribir el cuerpo de la función
  return(peso/(talla^2)) # return se usa para indicar el resultado de la función
}

# Para utilizar la función, hay dos alternativas:
# 1. Se escribe el nombre de la funcion, seguido de los argumentos, en el mismo orden que fueron declarados originalmente
imc(88, 1.78)
# 2. Se escribe la función y indican los valores de cada argumento usando su nombre y
# el operador '='
imc(peso = 88, talla = 1.78)
```


### Vectores

Un vector es un objeto que puede almacenar uno o más elementos del mismo tipo. Por ejemplo:

```{r, error=TRUE, eval = FALSE}
vector_character<- c("Ana", "Miguel", "Juan", "Lina") #Por ejemplo, nombre de las personas

vector_double <- c(15, 25, 32, 40)  #Por ejemplo la edad

vector_logic <- c(TRUE, FALSE, FALSE, TRUE) #Por ejemplo, ya fue vacunado

vector_integer <- c(1L, 0L, 0L, 2L) #Por ejemplo, número de dosis recibidas
```



Describa en sus palabras ¿Qué es un vector: double, logic, character e
integer? ¿Para qué los utilizaría? Proponga algunos ejemplos.

### Marco de datos (Data frames)

Un `data.frame` (marco de datos) es una estructura heterogénea y
bidimensional, similar pero no exactamente igual a una matriz. A
diferencia de una matriz, varios tipos de vectores pueden formar parte
de un solo marco de datos.

Los argumentos para el comando `data.frame` (marco de datos) son
simplemente las columnas en el marco de datos. Cada columna debe tener
el mismo número de filas para poder caber en un marco de datos.

Los marcos de datos no permiten vectores con diferentes longitudes.
Cuando la longitud del vector es menor que la longitud del marco de
datos, el marco de datos fuerza al vector a su longitud.

```{r, error=TRUE, eval = FALSE}
data_example <- data.frame(nombre = vector_character, edad = vector_double, estado_vacunacion = vector_logic, dosis = vector_integer)
```

Para acceder a la estructura general de un marco de datos usamos el
comando `str`

```{r, error=TRUE, eval = FALSE}
str(data_example)
```

Para acceder a los diferentes componentes del marco de datos usamos esta
sintaxis `[,]`, donde la primera dimensión corresponde a filas y la
segunda dimensión a columnas.

```{r, error=TRUE, eval = FALSE}
data_example[1, 2]
```


## 9. Crear y abrir conjuntos de datos

R permite a los usuarios no solo abrir, sino también crear conjuntos de
datos. Hay tres fuentes de conjuntos de datos:

-   Conjunto de datos importado (desde los formatos `.xlsx`, `.csv`,
    `.stata`, o `.RDS`, entre otros)
-   Conjunto de datos que forma parte de un paquete en R (Ej. MASS,
    islands, etc)
-   Conjunto de datos creado durante la sesión en R (Ej. las estructuras
    de los primeros ejercicios)

## 10. Importar un conjunto de datos

Para importar conjuntos de datos de diferentes fuentes necesitamos
emplear diferentes tipos de funciones, aquí algunos ejemplos del tipo de
datos, el paquete que es necesario cargar y la función a utilizar.

| Tipo de datos | Paquete                        | Función |
|---------------|--------------------------------|---------|
| csv           | read_csv                       | readr   |
| xls           | read_excel, read_xls,read_xlsx | readxl  |
| RDS           | readRDS                        | base    |
| dta           | read_dta                       | haven   |
| sas           | read_sas                       | haven   |
| sav           | read_spss                      | haven   |

## 11. Tidyverse

Para administrar mejor los conjuntos de datos, se recomienda instalar y
usar el paquete `tidyverse`, el cual carga automáticamente varios
paquetes (dplyr, tidyr, tibble, readr, purr, entre otros) que son útiles
para la manipulación de datos.

```{r,eval=FALSE,echo=TRUE}
install.packages('tidyverse')
```

```{r message=FALSE, warning=FALSE, include=TRUE}
library(tidyverse)
```

Abrir y explorar un conjunto de datos importados de Excel

Este es el conjunto de datos para esta práctica:
[datos_covid.xlsx](https://raw.githubusercontent.com/TRACE-LAC/TRACE-LAC-data/main/datos_covid.xlsx):

Dentro del directorio en el que está trabajando actualmente, cree una
carpeta llamada *data*. Guarde el conjunto de datos descargado en la
carpeta *data* que acaba de crear.

Para importar conjuntos de datos desde RDS, se puede usar la función
`read_excel`, que está en el paquete `readxl`vinculado a tidyverse. Sin
embargo, todavía es necesario cargar la biblioteca readxl, ya que no es
un paquete tidyverse principal.

```{r, eval=FALSE}
library(readxl)
dat <- read_excel("data/datos_covid.xlsx")
```

A continuación, verá algunas de las funciones más utilizadas de
`tidyverse`.

La función de tubería (pipe function) `%>%` es una función de uso
continuo. Por lo que es clave para usar tidyverse y facilita la
programación. La función de tubería permite al usuario enfatizar una
secuencia de acciones en un objeto.

Del paquete `dyplr`, las funciones más comunes son:

-   `glimpse`: utilizado para explorar rápidamente un conjunto de datos
-   `select`: extrae columnas de un conjunto de datos
-   `filter`: extrae filas de un conjunto de casos
-   `arrange`: ordena filas de un conjunto de datos por el valor de una
    variable particular si es numérico, o por orden alfabético si es un
    carácter
-   `summarise`: genera tablas resumen. Reduce las dimensiones de un
    conjunto de datos
-   `group_by`: crea grupos dentro de un conjunto de datos. las
    funciones del `dplyr` manipulan cada grupo por separado y luego
    combina los resultados
-   `mutate`: genera una nueva variable
-   `rename`: cambia el nombre de la variable

Explore información de los datos como: número de filas (que en este caso
sería el número de observaciones o datos de nuestra población), número
de columnas y sus nombres (que en este caso serían el número de
variables y sus nombres), entre "\< \>" encontrará el tipo de dato (dbl
para `double`, chr para `character`, entre otros) y un breve listado de
algunos de los primeros valores de los datos.

```{r, error=TRUE, eval = FALSE}
dat %>% glimpse()
```

En caso de querer extraer una o varias columnas puede emplear la función
`select`.

```{r, error=TRUE, eval = FALSE}
dat %>% select(edad) #empleando el nombre de la columna
dat %>% select(c(1,2)) #o su ubicación en los datos
```

Otra función de gran utilidad es `filter`. En esta se puede usar una o
más condiciones. Por ejemplo, filtre por los pacientes menores de 28
años.

```{r, error=TRUE, eval = FALSE}
dat %>% filter(edad < 28)
```

Como puede observar tiene todas las variables de la tabla pero los datos
se limitan a aquellos que en edad sean menores de 28 años.

Ahora filtre por los de 28 o menos años de sexo femenino. En este caso,
al pedir que se incluyan adicionalmente los de 28 años también ya no se
emplea unicamente el signo "\<" sino que se lo acompaña del símbolo "=".

```{r, error=TRUE, eval = FALSE}
dat %>% glimpse() #Observe como están expresadas las variables también puede usar la función `table()`
dat %>% filter(sexo == "F", edad <= 28) #Ahora sabe como filtrar el sexo
```

Para los casos donde se necesita organizar los datos por una o más
variables, se puede emplear la función `arrange`. Organice los datos por
edad.

```{r, error=TRUE, eval = FALSE}
dat %>% arrange(edad)
dat %>% arrange(edad,sexo)
```

Por configuración predeterminada la función organiza los valores de
menor a mayor, en caso de querer organizarlos de mayor a menor se puede
emplear `desc` al interior de la función `arrange`.

```{r, error=TRUE, eval = FALSE}
dat %>% arrange(desc(edad))
```

La función `summarise` permite resumir los datos.

```{r, error=TRUE, eval = FALSE}
dat %>% summarise(media = mean(edad), número = n())
```

La función `group_by` no tiene un uso evidente si es empleada sola, dado
que ocurre un proceso interno de agrupación de los datos. Pero al ser
usada con otras funciones como por ejemplo `summarise` es posible ver su
efecto.

```{r, error=TRUE, eval = FALSE}
dat %>% group_by(sexo) %>% summarise(número = n(), media_edad = mean(edad))
```

Para crear una nueva columna con datos de una ya existente resulta de
utilidad la función `mutate`. Esta función requiere el nombre de la
columna a crear y de la columna de la que queremos copiar los datos. La
columna nueva por configuración predeterminada se ubicará al final de
las variables.

```{r, error=TRUE, eval = FALSE}
dat %>% mutate(fecha_inicio_sintomas = fecha_de_inicio_de_sintomas)
```

Sin embargo, en caso de que no se desee crear una nueva variable sino
renombrar una ya existente conviene usar la función `rename`. Cambie el
nombre *nombre_departamento* por el nombre *departamento*.

```{r, error=TRUE, eval = FALSE}
dat %>% rename( departamento = nombre_departamento)
```

Ya se vio previamente cómo seleccionar columnas, en caso de las filas la
función `slice` resulta de gran utilidad.

```{r, error=TRUE, eval = FALSE}
dat %>% slice(10:15)
```

En caso de no querer usar tidyverse esta acción podría realizarse
mediante el siguiente comando:

```{r, error=TRUE, eval = FALSE}
dat[10:15, ]
```

Sin embargo, usar tidyverse y sus funciones resulta de gran utilidad.
Por ejemplo para tener los primeros 5 sujetos de la base que tengan
edades entre 13 y 14 años por cada sexo. Usando tidyverse se vería así:

```{r, error=TRUE, eval = FALSE}
dat %>% group_by(sexo) %>% filter(edad >= 13, edad <=14) %>% slice(1:5)
```

En caso de uno usar la función tubería (pipe) se vería así:

```{r, error=TRUE, eval = FALSE}
 slice(filter(group_by(dat, sexo),edad >= 13, edad <=14),1:5)
```

Como puede notar el resultado es el mismo, pero el primer caso es
preferible cuando se aplican varias funciones en conjunto. Dado que cómo
se puede ver permite un mayor orden del código y por tanto, una lectura
más fácil y si es necesario modificar algún aspecto es más accesible.

El paquete `tidiverse` normalmente viene acompañado de otros paquetes
como `tidyr`. Del paquete`tidyr`, las funciones más comunes son:

-   `pivot_longer`: apila en filas datos dispersos en columnas. Es una
    versión actualizada de `gather`
-   `pivot_wider`: dispersa en columnas datos apilados. Es una versión
    actualizada de `spread`

Los datos que en este caso llamados *dat* (se pueden observar en el
*Enviroment*) están en formato long, se seleccionarán tres columnas para
dar un ejemplo:

```{r, error=TRUE, eval = FALSE}
datos_wide <- dat %>% select(id_de_caso,nombre_departamento,nombre_municipio)
```

Como se puede observar cada número de identificación corresponde a una
fila que tiene nombre del departamento y nombre del municipio. A
continuación, se puede observar que pasa cuando esta selección la
pasamos de wide a long.

```{r, error=TRUE, eval = FALSE}

datos_long <- datos_wide %>% pivot_longer(nombre_departamento:nombre_municipio, names_to = "organizacion_territorial", values_to= "nombre_lugar")

datos_long
```

Ahora cada uno de los números de identificación ocupan doble fila, en
una contienen el municipio y en otra el departamento. Para poder
revertir esta acción se emplearían los siguientes comandos.

```{r, error=TRUE, eval = FALSE}

datos_wide2 <- datos_long %>% pivot_wider(names_from = "organizacion_territorial", values_from= "nombre_lugar")

datos_wide2
```

#### Ejercicio

Esta vez se cargará un tipo diferente de datos, estos los puede
encontrar en el enlace
<https://github.com/TRACE-LAC/TRACE-LAC-data/blob/main/datos_covid.RDS?raw=true>.
Los datos pueden ser cargados desde el computador o desde una ubicación
en internet. Para este ejercicio cargue la base de datos datos_covid.RDS
directamente desde internet con los comandos:

```{r, error=TRUE, eval = FALSE}
url <- "https://github.com/TRACE-LAC/TRACE-LAC-data/blob/main/datos_covid.RDS?raw=true"

covid <- readr::read_rds(url)
```

Por favor, realice las siguientes actividades:

-   Explore los datos

Como puede observar los nombres de las columnas (variables) están con
algunas letras en mayúsculas, otras con tildes y con espacios. Lo
primero que es necesario hacer es poner los nombres en una forma que
permitan evitar errores, es decir, todos en minúsculas, sin caracteres
especiales, tildes ni espacios. Para ello se usará la función
`clean_labels` del paquete `epitrix`.

```{r, error=TRUE, eval = FALSE}
#Primero se llamarán los nombres de las variables con la función `names`
names(covid)
#ahora a estos nombres se les reasignará nombres limpios
names(covid) <- names(covid) %>% epitrix::clean_labels()

names(covid)
```

Ahora que los nombres están limpios es posible proseguir.

-   Filtre los datos para Cali (observe bien cómo están escritos los
    datos dentro de la variables)
-   Agrupe los datos por departamento y cuente los casos por cada uno.
-   Agrupe los datos por departamento y saque la media de edad de cada
    uno.
-   Cambie el nombre de estado por gravedad.
-   Ordene los datos por sexo y seleccione las 5 primeras filas de cada
    uno.
-   Agrupe los datos por etnia, filtrelos para Bogotá y seleccione las
    primeras 5 filas.
-   Seleccione las 5 primeras filas de solo el número de identificación
    del caso.

### Enlaces utiles

[Introducción a
R](http://people.umass.edu/biep640w/pdf/RStudio101%20-%20Introduction%20by%20Oscar%20Torres-Reyna.pdf)

[Historia de
R](https://www.genbeta.com/desarrollo/introduccion-a-r-historia-de-un-lenguaje-de-computacion-para-el-analisis-de-datos)

## Contribuciones

-   Zulma M. Cucunuba: Versión inicial
-   Zhian N. Kamvar: Ediciones menores
-   Kelly A. Charniga: Ediciones menores
-   José M. Velasco-España: Traducción de Inglés a Español y edición
-   Andree Valle-Campos: Ediciones menores
-   Jaime A. Pavlich-Mariscal: Edición

Contribuciones son bienvenidas vía [pull
requests](https://github.com/reconhub/learn/pulls).

## Asuntos legales

**Licencia**: [CC-BY](https://creativecommons.org/licenses/by/3.0/)
**Copyright**: Zulma M. Cucunuba, 2019
